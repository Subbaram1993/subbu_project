name: CMake Build, Test, and Update Tag with Jenkins Build Number

on:
  workflow_run:
    workflows: 
      - "Trigger Jenkins Build and Update Build Numbers"
    types:
      - completed
    conclusion: success

env:
  BUILD_TYPE: Release
  JENKINS_URL: ${{ secrets.JENKINS_URL }}
  JENKINS_USER: ${{ secrets.JENKINS_USER }}
  JENKINS_API_TOKEN: ${{ secrets.JENKINS_API_TOKEN }}
  LOG_FILE: "./build_and_test.log"

jobs:
  build-and-tag:
    runs-on: self-hosted

    steps:
      # Checkout the repository
      - name: Checkout Code
        uses: actions/checkout@v4

      # Read the config.json and set the jobName as an environment variable
      - name: Set Job Name from config.json
        id: set_job_name
        run: |
          echo "Setting Job Name from config.json" >> $LOG_FILE
          if [ ! -f config.json ]; then
            echo "config.json not found!" >> $LOG_FILE
            exit 1
          fi
          JOB_NAME=$(jq -r '.buildConfig.jobName' config.json)
          echo "JOB_NAME=${JOB_NAME}" >> $GITHUB_ENV
          echo "Job Name set: ${JOB_NAME}" >> $LOG_FILE

      # Configure CMake
      - name: Configure CMake
        id: configure_cmake
        run: |
          echo "Configuring CMake..." >> $LOG_FILE
          mkdir -p build
          cmake -S . -B build -DCMAKE_BUILD_TYPE=${{env.BUILD_TYPE}} >> $LOG_FILE 2>&1

      # Build the project
      - name: Build
        id: build_project
        run: |
          echo "Building the project..." >> $LOG_FILE
          cmake --build build --config ${{env.BUILD_TYPE}} >> $LOG_FILE 2>&1

      # Run CMake Tests
      - name: Run CMake Tests
        id: run_cmake_tests
        working-directory: build
        run: |
          echo "Running CMake Tests..." >> $LOG_FILE
          ctest -C ${{env.BUILD_TYPE}} --output-on-failure >> $LOG_FILE 2>&1

      # Compile and Run C Test Suite
      - name: Compile and Run C Test Suite
        id: compile_and_run_tests
        run: |
          echo "Compiling and Running C Test Suite..." >> $LOG_FILE
          TEST_DIR="subbu_project/test"
          SRC_DIR="src"
          for test_file in $TEST_DIR/*.c; do
            base_name=$(basename "$test_file" .c)
            source_file="$SRC_DIR/${base_name#test_}.c"
            if [ ! -f "$source_file" ]; then
              echo "Source file $source_file not found for test $test_file. Skipping..." >> $LOG_FILE
              continue
            fi
            echo "Compiling test: $base_name" >> $LOG_FILE
            gcc -Wall -Wextra -O2 -o "test_${base_name}" "$test_file" "$source_file" >> $LOG_FILE 2>&1
            echo "Running test for ${base_name}" >> $LOG_FILE
            ./test_${base_name} >> $LOG_FILE 2>&1
          done

      # Pull Latest Changes and Handle Conflicts
      - name: Pull Latest Changes and Handle Conflicts
        id: pull_changes
        run: |
          echo "Pulling latest changes..." >> $LOG_FILE
          git config user.name "${{ github.actor }}" >> $LOG_FILE 2>&1
          git config user.email "${{ secrets.GIT_EMAIL }}" >> $LOG_FILE 2>&1
          git config --global commit.gpgSign true >> $LOG_FILE 2>&1
          git config --global user.signingkey "${{ secrets.GPG_KEY_ID }}" >> $LOG_FILE 2>&1
          
          git stash || echo "Nothing to stash" >> $LOG_FILE
          git pull origin main --rebase || {
            echo "Merge conflict detected. Resolving automatically using 'theirs'." >> $LOG_FILE
            git checkout --theirs . >> $LOG_FILE 2>&1
            git add . >> $LOG_FILE 2>&1
            git rebase --continue || {
              git rebase --abort >> $LOG_FILE 2>&1
              exit 1
            }
          }
          git stash pop || echo "No stashed changes to apply" >> $LOG_FILE

      # Fetch Latest Jenkins Build Number
      - name: Get Latest Jenkins Build Number
        id: get_jenkins_build_number
        run: |
          echo "Fetching latest Jenkins build number..." >> $LOG_FILE
          BUILD_NUMBER=$(curl -s -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_API_TOKEN }}" \
            "${{ secrets.JENKINS_URL }}/job/${{ env.JOB_NAME }}/lastSuccessfulBuild/buildNumber")
          if [ -z "$BUILD_NUMBER" ]; then
            echo "Failed to fetch the Jenkins build number!" >> $LOG_FILE
            exit 1
          fi
          echo "BUILD_NUMBER=${BUILD_NUMBER}" >> $GITHUB_ENV
          echo "Build number fetched: $BUILD_NUMBER" >> $LOG_FILE

      # Determine Version
      - name: Determine Version
        id: determine_version
        run: |
          echo "Determining version based on build number..." >> $LOG_FILE
          PATCH=$((BUILD_NUMBER % 10))
          MINOR=$((BUILD_NUMBER / 10 % 6))
          MAJOR=$((BUILD_NUMBER / 60))
          VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "VERSION=${VERSION}" >> $GITHUB_ENV
          echo "Determined version: $VERSION" >> $LOG_FILE

      # Retrieve Artifacts
      - name: Retrieve Artifacts
        id: retrieve_artifacts
        run: |
          echo "Retrieving artifacts..." >> $LOG_FILE
          ARTIFACTS_DIR="artifacts"
          mkdir -p $ARTIFACTS_DIR
          
          curl -s -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_API_TOKEN }}" \
            "${{ secrets.JENKINS_URL }}/job/${{ env.JOB_NAME }}/lastSuccessfulBuild/artifact/*zip*/archive.zip" \
            -o $ARTIFACTS_DIR/archive.zip >> $LOG_FILE 2>&1
          
          if [ ! -f "$ARTIFACTS_DIR/archive.zip" ]; then
            echo "Artifact download failed!" >> $LOG_FILE
            exit 1
          fi
          unzip -o $ARTIFACTS_DIR/archive.zip -d $ARTIFACTS_DIR >> $LOG_FILE 2>&1
          echo "Artifacts retrieved and saved to $ARTIFACTS_DIR" >> $LOG_FILE

      # Save Artifacts in Repository
      - name: Save Artifacts to Repo
        id: save_artifacts
        run: |
          echo "Saving artifacts to repository..." >> $LOG_FILE
          git add artifacts/ >> $LOG_FILE 2>&1
          git commit -S -m "Add artifacts and Incremented the TAG version ${{ env.VERSION }}" || echo "No changes to commit" >> $LOG_FILE 2>&1

      # Create and Push Tag
      - name: Create and Push Tag
        id: create_and_push_tag
        run: |
          echo "Creating and pushing tag..." >> $LOG_FILE
          TAG_NAME="${{ env.VERSION }}"
          git tag -f "$TAG_NAME" >> $LOG_FILE 2>&1
          git push origin --force "$TAG_NAME" >> $LOG_FILE 2>&1

      # Push Changes
      - name: Push Changes
        id: push_changes
        run: |
          echo "Pushing changes to the repository..." >> $LOG_FILE
          git push origin main >> $LOG_FILE 2>&1
