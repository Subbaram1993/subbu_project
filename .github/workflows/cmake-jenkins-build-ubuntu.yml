name: CMake Build, Test, and Update Tag with Jenkins Build Number

on:
  workflow_run:
    workflows:
      - "Trigger Jenkins Build and Update Build Numbers"
    types:
      - completed
    conclusion: success

env:
  BUILD_TYPE: Release
  JENKINS_URL: ${{ secrets.JENKINS_URL }}
  JENKINS_USER: ${{ secrets.JENKINS_USER }}
  JENKINS_API_TOKEN: ${{ secrets.JENKINS_API_TOKEN }}
  LOG_FILE: "./build_and_test.log"

jobs:
  build-and-tag:
    runs-on: self-hosted

    steps:
      # Checkout the repository
      - name: Checkout Code
        uses: actions/checkout@v4

      # Read the config.json and set the jobName as an environment variable
      - name: Set Job Name from config.json
        id: set_job_name
        run: |
          echo "Setting Job Name from config.json" >> ${{ env.LOG_FILE }}
          if [ ! -f config.json ]; then
            echo "config.json not found!" >> ${{ env.LOG_FILE }}
            exit 1
          fi
          JOB_NAME=$(jq -r '.buildConfig.jobName' config.json)
          echo "JOB_NAME=${JOB_NAME}" >> $GITHUB_ENV
          echo "Job Name set: ${JOB_NAME}" >> ${{ env.LOG_FILE }}

      # Configure CMake
      - name: Configure CMake
        id: configure_cmake
        run: |
          echo "Configuring CMake..." >> ${{ env.LOG_FILE }}
          mkdir -p build
          cmake -S . -B build -DCMAKE_BUILD_TYPE=${{env.BUILD_TYPE}} >> ${{ env.LOG_FILE }} 2>&1

      # Build the project
      - name: Build
        id: build_project
        run: |
          echo "Building the project..." >> ${{ env.LOG_FILE }}
          cmake --build build --config ${{env.BUILD_TYPE}} >> ${{ env.LOG_FILE }} 2>&1

      # Run CMake Tests
      - name: Run CMake Tests
        id: run_cmake_tests
        working-directory: build
        run: |
          echo "Running CMake Tests..." >> ../${{ env.LOG_FILE }}
          ctest -C ${{env.BUILD_TYPE}} --output-on-failure >> ../${{ env.LOG_FILE }} 2>&1

      # Compile and Run C Test Suite
      - name: Compile and Run C Test Suite
        id: compile_and_run_tests
        run: |
          echo "Compiling and Running C Test Suite..." >> ${{ env.LOG_FILE }}
          TEST_DIR="subbu_project/test"
          SRC_DIR="src"
          for test_file in $TEST_DIR/*.c; do
            base_name=$(basename "$test_file" .c)
            source_file="$SRC_DIR/${base_name#test_}.c"
            if [ ! -f "$source_file" ]; then
              echo "Source file $source_file not found for test $test_file. Skipping..." >> ${{ env.LOG_FILE }}
              continue
            fi
            echo "Compiling test: $base_name" >> ${{ env.LOG_FILE }}
            gcc -Wall -Wextra -O2 -o "test_${base_name}" "$test_file" "$source_file" >> ${{ env.LOG_FILE }} 2>&1
            echo "Running test for ${base_name}" >> ${{ env.LOG_FILE }}
            ./test_${base_name} >> ${{ env.LOG_FILE }} 2>&1
          done

      # Pull Latest Changes and Handle Conflicts
      - name: Pull Latest Changes and Handle Conflicts
        id: pull_changes
        run: |
          echo "Pulling latest changes..." >> ${{ env.LOG_FILE }}
          git config user.name "${{ github.actor }}" >> ${{ env.LOG_FILE }} 2>&1
          git config user.email "${{ secrets.GIT_EMAIL }}" >> ${{ env.LOG_FILE }} 2>&1
          git config --global commit.gpgSign true >> ${{ env.LOG_FILE }} 2>&1
          git config --global user.signingkey "${{ secrets.GPG_KEY_ID }}" >> ${{ env.LOG_FILE }} 2>&1
          
          git stash || echo "Nothing to stash" >> ${{ env.LOG_FILE }}
          git pull origin main --rebase || {
            echo "Merge conflict detected. Resolving automatically using 'theirs'." >> ${{ env.LOG_FILE }}
            git checkout --theirs . >> ${{ env.LOG_FILE }} 2>&1
            git add . >> ${{ env.LOG_FILE }} 2>&1
            git rebase --continue || {
              git rebase --abort >> ${{ env.LOG_FILE }} 2>&1
              exit 1
            }
          }
          git stash pop || echo "No stashed changes to apply" >> ${{ env.LOG_FILE }}

      # Fetch Latest Jenkins Build Number
      - name: Get Latest Jenkins Build Number
        id: get_jenkins_build_number
        run: |
          echo "Fetching latest Jenkins build number..." >> ${{ env.LOG_FILE }}
          BUILD_NUMBER=$(curl -s -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_API_TOKEN }}" \
            "${{ secrets.JENKINS_URL }}/job/${{ env.JOB_NAME }}/lastSuccessfulBuild/buildNumber")
          if [ -z "$BUILD_NUMBER" ]; then
            echo "Failed to fetch the Jenkins build number!" >> ${{ env.LOG_FILE }}
            exit 1
          fi
          echo "BUILD_NUMBER=${BUILD_NUMBER}" >> $GITHUB_ENV
          echo "Build number fetched: $BUILD_NUMBER" >> ${{ env.LOG_FILE }}

      # Determine Version
      - name: Determine Version
        id: determine_version
        run: |
          echo "Determining version based on build number..." >> ${{ env.LOG_FILE }}
          PATCH=$((BUILD_NUMBER % 10))
          MINOR=$((BUILD_NUMBER / 10 % 6))
          MAJOR=$((BUILD_NUMBER / 60))
          VERSION="v${MAJOR}.${MINOR}.${PATCH}"
          echo "VERSION=${VERSION}" >> $GITHUB_ENV
          echo "Determined version: $VERSION" >> ${{ env.LOG_FILE }}

      # Retrieve Artifacts
      - name: Retrieve Artifacts
        id: retrieve_artifacts
        run: |
          echo "Retrieving artifacts..." >> ${{ env.LOG_FILE }}
          ARTIFACTS_DIR="artifacts"
          mkdir -p $ARTIFACTS_DIR
          
          curl -s -u "${{ secrets.JENKINS_USER }}:${{ secrets.JENKINS_API_TOKEN }}" \
            "${{ secrets.JENKINS_URL }}/job/${{ env.JOB_NAME }}/lastSuccessfulBuild/artifact/*zip*/archive.zip" \
            -o $ARTIFACTS_DIR/archive.zip >> ${{ env.LOG_FILE }} 2>&1
          
          if [ ! -f "$ARTIFACTS_DIR/archive.zip" ]; then
            echo "Artifact download failed!" >> ${{ env.LOG_FILE }}
            exit 1
          fi
          unzip -o $ARTIFACTS_DIR/archive.zip -d $ARTIFACTS_DIR >> ${{ env.LOG_FILE }} 2>&1
          echo "Artifacts retrieved and saved to $ARTIFACTS_DIR" >> ${{ env.LOG_FILE }}

      # Save Artifacts in Repository
      - name: Save Artifacts to Repo
        id: save_artifacts
        run: |
          echo "Saving artifacts to repository..." >> ${{ env.LOG_FILE }}
          git add artifacts/ >> ${{ env.LOG_FILE }} 2>&1
          git commit -S -m "Add artifacts and Incremented the TAG version ${{ env.VERSION }}" || echo "No changes to commit" >> ${{ env.LOG_FILE }} 2>&1

      # Create and Push Tag
      - name: Create and Push Tag
        id: create_and_push_tag
        run: |
          echo "Creating and pushing tag..." >> ./build_and_test.log
          TAG_NAME="${{ env.VERSION }}"

          # Debugging: Check repository state
          echo "Repository remote status:" >> ./build_and_test.log
          git remote -v >> ./build_and_test.log 2>&1
          
          echo "Fetching latest changes..." >> ./build_and_test.log
          git fetch origin --tags >> ./build_and_test.log 2>&1

          echo "Pulling latest changes..." >> ./build_and_test.log
          git pull origin main --rebase >> ./build_and_test.log 2>&1

          # Check if the tag exists remotely
          if git ls-remote --tags origin | grep -qw "refs/tags/$TAG_NAME"; then
            echo "Tag $TAG_NAME exists remotely. Deleting it first..." >> ./build_and_test.log
            git push origin :refs/tags/"$TAG_NAME" >> ./build_and_test.log 2>&1
          fi

          # Create or overwrite the tag locally
          echo "Creating tag $TAG_NAME locally..." >> ./build_and_test.log
          git tag -f "$TAG_NAME" >> ./build_and_test.log 2>&1

          # Push the tag to the remote
          echo "Pushing tag $TAG_NAME to remote..." >> ./build_and_test.log
          git push origin --force "$TAG_NAME" >> ./build_and_test.log 2>&1
          
        shell: bash

      # Debug Logs
      - name: Debug Logs
        if: failure()
        run: cat ./build_and_test.log

      # Push Changes
      - name: Push Changes
        id: push_changes
        run: |
          echo "Pushing changes to the repository..." >> ${{ env.LOG_FILE }}
          git push origin main >> ${{ env.LOG_FILE }} 2>&1
